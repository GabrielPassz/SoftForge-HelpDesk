const STATIC_CACHE = 'static-v6';
const RUNTIME_CACHE = 'runtime-v6';

self.addEventListener('install', event => {
    self.skipWaiting();
    event.waitUntil(caches.open(STATIC_CACHE).then(c => c.addAll([
        '/',
        '/manifest.webmanifest',
        '/icons/icon-192.png',
        '/icons/icon-512.png'
    ].filter(Boolean))));
});

self.addEventListener('activate', event => {
    event.waitUntil(
        (async () => {
            const keys = await caches.keys();
            await Promise.all(keys.filter(k => k !== STATIC_CACHE && k !== RUNTIME_CACHE).map(k => caches.delete(k)));
            await self.clients.claim();
        })()
    );
});

function isAuth(reqUrl){
    const path = new URL(reqUrl).pathname.toLowerCase();
    return path.includes('/site/login') || path.includes('/site/logout') || path.includes('/site/registrocadastro');
}

self.addEventListener('fetch', event => {
    const req = event.request;
    if (req.method !== 'GET') { event.respondWith(fetch(req)); return; }

    // Navigations (HTML): network-first to avoid stale pages
    if (req.mode === 'navigate') {
        event.respondWith(
            (async () => {
                try { return await fetch(req, { cache: 'no-store', credentials: 'same-origin' }); }
                catch { return (await caches.match('/')) || new Response('Offline', { status:503 }); }
            })()
        );
        return;
    }

    // Auth endpoints: never cache; also clear caches on logout
    if (isAuth(req.url)) {
        event.respondWith(fetch(req, { cache: 'no-store', credentials: 'same-origin' }).then(r => {
            if (new URL(req.url).pathname.toLowerCase().includes('/site/logout')) {
                caches.keys().then(keys => Promise.all(keys.map(k => caches.delete(k))));
            }
            return r;
        }));
        return;
    }

    const urlObj = new URL(req.url);
    const isCssJs = urlObj.pathname.endsWith('.css') || urlObj.pathname.endsWith('.js');
    const isStaticAsset = req.destination === 'style' || req.destination === 'script' || req.destination === 'image' || isCssJs;

    // CSS/JS: network-first to always get latest; cache as fallback
    if (isCssJs) {
        event.respondWith(
            fetch(req, { cache: 'no-store' })
            .then(resp => { const clone = resp.clone(); caches.open(RUNTIME_CACHE).then(c => c.put(req, clone)); return resp; })
            .catch(() => caches.match(req))
        );
        return;
    }

    // Other static assets (images etc): cache-first
    if (isStaticAsset) {
        event.respondWith(
            caches.match(req).then(cached => cached || fetch(req).then(resp => { const clone = resp.clone(); caches.open(RUNTIME_CACHE).then(c => c.put(req, clone)); return resp; }))
        );
        return;
    }

    // Default: network-first with cache fallback
    event.respondWith(
        fetch(req).then(resp => { const clone = resp.clone(); caches.open(RUNTIME_CACHE).then(c => c.put(req, clone)); return resp; }).catch(() => caches.match(req))
    );
});
