const STATIC_CACHE = 'static-v5';
const RUNTIME_CACHE = 'runtime-v5';

self.addEventListener('install', event => {
    self.skipWaiting();
    event.waitUntil(caches.open(STATIC_CACHE).then(c => c.addAll([
        '/',
        '/css/site.css',
        '/css/dbtestes.css',
        '/js/site.js',
        '/manifest.webmanifest',
        '/icons/icon-192.png',
        '/icons/icon-512.png'
    ].filter(Boolean))));
});

self.addEventListener('activate', event => {
    event.waitUntil(
        (async () => {
            const keys = await caches.keys();
            await Promise.all(keys.filter(k => k !== STATIC_CACHE && k !== RUNTIME_CACHE).map(k => caches.delete(k)));
            await self.clients.claim();
        })()
    );
});

function isAuth(reqUrl) {
    const path = new URL(reqUrl).pathname.toLowerCase();
    return path.includes('/site/login') || path.includes('/site/logout') || path.includes('/site/registrocadastro');
}

self.addEventListener('fetch', event => {
    const req = event.request;
    // Non-GET: network only
    if (req.method !== 'GET') { event.respondWith(fetch(req)); return; }

    // Navigations (HTML): network-first, no-store to avoid stale sessions
    if (req.mode === 'navigate') {
        event.respondWith(
            (async () => {
                try { return await fetch(req, { cache: 'no-store', credentials: 'same-origin' }); }
                catch { return (await caches.match('/')) || new Response('Offline', { status: 503 }); }
            })()
        );
        return;
    }

    // Auth endpoints: never cache; also clear caches on logout
    if (isAuth(req.url)) {
        event.respondWith(fetch(req, { cache: 'no-store', credentials: 'same-origin' }).then(r => {
            if (new URL(req.url).pathname.toLowerCase().includes('/site/logout')) {
                caches.keys().then(keys => Promise.all(keys.map(k => caches.delete(k))));
            }
            return r;
        }));
        return;
    }

    const urlObj = new URL(req.url);
    const isStatic = req.destination === 'style' || req.destination === 'script' || req.destination === 'image' || urlObj.pathname.endsWith('.css') || urlObj.pathname.endsWith('.js');

    if (isStatic) {
        // Se houver query (?rev=) sempre busca rede para garantir atualização
        if (urlObj.search.includes('rev=')) {
            event.respondWith(fetch(req).then(resp => {
                const clone = resp.clone(); caches.open(RUNTIME_CACHE).then(c => c.put(req, clone)); return resp;
            }).catch(() => caches.match(req)));
            return;
        }
        event.respondWith(caches.match(req).then(cached => cached || fetch(req).then(resp => { const clone = resp.clone(); caches.open(RUNTIME_CACHE).then(c => c.put(req, clone)); return resp; })));
        return;
    }

    // Default: network-first with fallback
    event.respondWith(fetch(req).then(resp => { const clone = resp.clone(); caches.open(RUNTIME_CACHE).then(c => c.put(req, clone)); return resp; }).catch(() => caches.match(req)));
});
