using System.Net.Http;
using System.Text;
using System.Text.Json;
using System.Text.Json.Serialization;
using Microsoft.Extensions.Configuration;
using System.Text.RegularExpressions;
using System.Collections.Generic;
using System.Linq;

namespace PIM_FINAL.Services
{
    public interface IAiService
    {
        Task<(string Categoria, string Prioridade, string Justificativa)> ClassifyAsync(
        string titulo,
        string descricao,
        IEnumerable<string> categorias,
        IEnumerable<string> normas,
        CancellationToken ct = default);

        Task<string> SuggestInitialReplyAsync(string titulo, string descricao, CancellationToken ct = default);
        Task<string> SummarizeAsync(string text, CancellationToken ct = default);
        Task<string[]> ExtractKeywordsAsync(string text, CancellationToken ct = default);
    }

    public class RapidAiService : IAiService
    {
        private readonly IHttpClientFactory _httpClientFactory;
        private readonly IConfiguration _config;
        private readonly JsonSerializerOptions _jsonOptions = new(JsonSerializerDefaults.Web)
        {
            DefaultIgnoreCondition = JsonIgnoreCondition.WhenWritingNull,
            PropertyNamingPolicy = JsonNamingPolicy.CamelCase
        };

        public RapidAiService(IHttpClientFactory httpClientFactory, IConfiguration config)
        {
            _httpClientFactory = httpClientFactory;
            _config = config;
        }

        private record ChatMessage([property: JsonPropertyName("role")] string Role,
        [property: JsonPropertyName("content")] string Content);
        private record ChatRequest([property: JsonPropertyName("messages")] List<ChatMessage> Messages,
        [property: JsonPropertyName("web_access")] bool WebAccess = false);

        private async Task<string> ChatAsync(string userPrompt, CancellationToken ct)
        {
            var baseUrl = _config["RapidAI:BaseUrl"] ?? "https://open-ai21.p.rapidapi.com/conversationllama";
            var host = _config["RapidAI:Host"] ?? "open-ai21.p.rapidapi.com";
            var apiKey = _config["RapidAI:ApiKey"];
            if (string.IsNullOrWhiteSpace(apiKey))
                throw new InvalidOperationException("RapidAI:ApiKey não configurado.");

            var client = _httpClientFactory.CreateClient("RapidAI");
            using var request = new HttpRequestMessage(HttpMethod.Post, baseUrl);
            request.Headers.Add("X-RapidAPI-Key", apiKey);
            request.Headers.Add("X-RapidAPI-Host", host);
            var payload = new ChatRequest(new List<ChatMessage> { new("user", userPrompt) }, WebAccess: false);
            var json = JsonSerializer.Serialize(payload, _jsonOptions);
            request.Content = new StringContent(json, Encoding.UTF8, "application/json");

            using var response = await client.SendAsync(request, ct);
            var text = await response.Content.ReadAsStringAsync(ct);

            // If HTTP error -> return empty to avoid postar erro bruto ao usuário
            if (!response.IsSuccessStatusCode)
                return string.Empty;

            // Try parse and detect provider-side error envelope
            try
            {
                using var doc = JsonDocument.Parse(text);
                var root = doc.RootElement;

                // Common error shapes
                if ((root.TryGetProperty("status", out var st) && st.ValueKind == JsonValueKind.False) ||
                root.TryGetProperty("error", out _) || root.TryGetProperty("Error", out _))
                    return string.Empty; // treat as failure

                if (root.TryGetProperty("result", out var result)) return result.ToString();
                if (root.TryGetProperty("answer", out var answer)) return answer.ToString();
                if (root.TryGetProperty("output", out var output)) return output.ToString();
                if (root.TryGetProperty("response", out var resp)) return resp.ToString();
                if (root.TryGetProperty("message", out var message)) return message.ToString();
            }
            catch
            {
                // fall through, we'll return raw text
            }

            // As fallback return text (only if not obviously an error string)
            if (text.Contains("\"status\":false", StringComparison.OrdinalIgnoreCase) ||
            text.Contains("\"error\"", StringComparison.OrdinalIgnoreCase) ||
            text.Contains("\"Error\"", StringComparison.OrdinalIgnoreCase))
            {
                return string.Empty;
            }
            return text;
        }

        public async Task<(string Categoria, string Prioridade, string Justificativa)> ClassifyAsync(string titulo, string descricao, IEnumerable<string> categorias, IEnumerable<string> prioridades, CancellationToken ct = default)
        {
            var cats = string.Join(", ", categorias);
            var pris = string.Join(", ", prioridades);
            string basePrompt = $@"Você é um assistente de Help Desk. Com base no título e descrição abaixo, escolha UMA categoria e UMA prioridade dentre as listas fornecidas e responda APENAS em JSON compacto no formato:
{{""categoria"":""<uma das categorias>"",""prioridade"":""<uma das prioridades>"",""justificativa"":""<motivo curto>""}}

Categorias: [{cats}]
Prioridades: [{pris}]
Título: {titulo}
Descrição: {descricao}";
            var result = await ChatAsync(basePrompt, ct);

            (string cat, string pri, string jus) Parse(string content)
            {
                if (string.IsNullOrWhiteSpace(content)) return ("", "", "");
                // extrair bloco JSON se presente
                var match = Regex.Match(content, @"\{[\s\S]*?\}");
                string json = match.Success ? match.Value : content;
                try
                {
                    using var doc = JsonDocument.Parse(json);
                    var root = doc.RootElement;
                    string cat = root.TryGetProperty("categoria", out var c) ? c.GetString() ?? "" : (root.TryGetProperty("category", out var c2) ? c2.GetString() ?? "" : "");
                    string pri = root.TryGetProperty("prioridade", out var p) ? p.GetString() ?? "" : (root.TryGetProperty("priority", out var p2) ? p2.GetString() ?? "" : "");
                    string jus = root.TryGetProperty("justificativa", out var j) ? j.GetString() ?? "" : (root.TryGetProperty("justification", out var j2) ? j2.GetString() ?? "" : "");
                    return (cat, pri, jus);
                }
                catch
                {
                    // regex pares simples categoria: X prioridade: Y
                    var catM = Regex.Match(content, @"(categoria|category)\s*[:=-]\s*([A-Za-zÁ-ú0-9 ]+)", RegexOptions.IgnoreCase);
                    var priM = Regex.Match(content, @"(prioridade|priority)\s*[:=-]\s*([A-Za-zÁ-ú0-9 ]+)", RegexOptions.IgnoreCase);
                    var jusM = Regex.Match(content, @"(justificativa|justification)\s*[:=-]\s*(.+)", RegexOptions.IgnoreCase);
                    return (catM.Success ? catM.Groups[2].Value.Trim() : "",
                    priM.Success ? priM.Groups[2].Value.Trim() : "",
                    jusM.Success ? jusM.Groups[2].Value.Trim() : content.Trim());
                }
            }

            var (categoria, prioridade, justificativa) = Parse(result);

            // Segunda tentativa se vazio (prompt ultra rígido)
            if (string.IsNullOrWhiteSpace(categoria) || string.IsNullOrWhiteSpace(prioridade))
            {
                string strictPrompt = $@"RETORNE SOMENTE JSON SEM TEXTO EXTRA: {{""categoria"":""<uma das categorias>"",""prioridade"":""<uma das prioridades>"",""justificativa"":""<motivo curto>""}}\nCategorias: [{cats}]\nPrioridades: [{pris}]\nTítulo: {titulo}\nDescrição: {descricao}";
                var strictResult = await ChatAsync(strictPrompt, ct);
                var parsed2 = Parse(strictResult);
                if (!string.IsNullOrWhiteSpace(parsed2.cat)) categoria = parsed2.cat;
                if (!string.IsNullOrWhiteSpace(parsed2.pri)) prioridade = parsed2.pri;
                if (string.IsNullOrWhiteSpace(justificativa) && !string.IsNullOrWhiteSpace(parsed2.jus)) justificativa = parsed2.jus;
            }

            // Normalização para casar com listas
            string Normalize(string s)
            {
                if (string.IsNullOrWhiteSpace(s)) return "";
                s = s.Trim().ToLowerInvariant();
                s = s.Replace("ç", "c").Replace("á", "a").Replace("à", "a").Replace("ã", "a").Replace("â", "a")
                .Replace("é", "e").Replace("ê", "e").Replace("í", "i").Replace("ó", "o").Replace("ô", "o").Replace("õ", "o").Replace("ú", "u");
                return Regex.Replace(s, "[^a-z0-9]", "");
            }
            var catMap = categorias.ToDictionary(c => Normalize(c), c => c, StringComparer.OrdinalIgnoreCase);
            var priMap = prioridades.ToDictionary(p => Normalize(p), p => p, StringComparer.OrdinalIgnoreCase);

            var catNorm = Normalize(categoria);
            if (!catMap.TryGetValue(catNorm, out var finalCat))
            {
                // tentativa por contains
                finalCat = catMap.Keys.FirstOrDefault(k => k.Contains(catNorm)) is string key && catMap.ContainsKey(key) ? catMap[key] : string.Empty;
            }
            var priNorm = Normalize(prioridade);
            if (!priMap.TryGetValue(priNorm, out var finalPri))
            {
                // sinônimos inglês
                var syn = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase)
                {
                    ["critical"] = "critica",
                    ["urgent"] = "critica",
                    ["high"] = "alta",
                    ["medium"] = "media",
                    ["normal"] = "media",
                    ["low"] = "baixa"
                };
                if (syn.TryGetValue(priNorm, out var mapped)) priNorm = Normalize(mapped);
                if (!priMap.TryGetValue(priNorm, out finalPri))
                    finalPri = priMap.Keys.FirstOrDefault(k => k.Contains(priNorm)) is string pKey && priMap.ContainsKey(pKey) ? priMap[pKey] : string.Empty;
            }

            return (finalCat, finalPri, justificativa);
        }

        public async Task<string> SuggestInitialReplyAsync(string titulo, string descricao, CancellationToken ct = default)
        {
            var prompt = $@"Você é técnico de suporte. Escreva uma resposta inicial curta, empática e objetiva para o solicitante, confirmando o recebimento e pedindo dados essenciais (logs, prints, passos para reproduzir). Use no máx.120 palavras.\n\nTítulo: {titulo}\nDescrição: {descricao}";
            var resp = await ChatAsync(prompt, ct);
            return string.IsNullOrWhiteSpace(resp) ? string.Empty : resp.Trim();
        }
        public Task<string> SummarizeAsync(string text, CancellationToken ct = default)
        {
            var prompt = $"Resuma em3 a5 bullets a conversa e ações abaixo, destacando status atual e próximos passos:\n\n{text}";
            return ChatAsync(prompt, ct);
        }
        public async Task<string[]> ExtractKeywordsAsync(string text, CancellationToken ct = default)
        {
            var prompt = $"Extraia de3 a8 palavras-chave em português, separadas por vírgula, do texto a seguir:\n{text}";
            var resp = await ChatAsync(prompt, ct);
            var parts = resp.Split(new[] { ',', '\n', ';' }, StringSplitOptions.RemoveEmptyEntries | StringSplitOptions.TrimEntries);
            return parts.Take(8).ToArray();
        }
    }
}
