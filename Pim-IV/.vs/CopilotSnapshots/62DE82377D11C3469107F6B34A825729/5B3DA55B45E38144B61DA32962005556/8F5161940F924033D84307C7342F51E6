self.addEventListener('install', event => {
    self.skipWaiting();
    event.waitUntil(caches.open('static-v4').then(c => c.addAll([
        '/',
        '/css/site.css',
        '/css/dbtestes.css',
        '/js/site.js',
        '/js/limitLists.js',
        '/manifest.webmanifest',
        '/icons/icon-192.png',
        '/icons/icon-512.png'
    ].filter(Boolean))));
});

self.addEventListener('activate', event => {
    event.waitUntil(
        (async () => {
            const keys = await caches.keys();
            await Promise.all(keys.filter(k => k !== 'static-v4' && k !== 'runtime-v4').map(k => caches.delete(k)));
            await self.clients.claim();
        })()
    );
});

function isAuth(reqUrl){
    const path = new URL(reqUrl).pathname.toLowerCase();
    return path.includes('/site/login') || path.includes('/site/logout') || path.includes('/site/registrocadastro');
}

self.addEventListener('fetch', event => {
    const req = event.request;
    // Non-GET: network only
    if (req.method !== 'GET') { event.respondWith(fetch(req)); return; }

    // Navigations (HTML): network-first, no-store to avoid stale sessions
    if (req.mode === 'navigate') {
        event.respondWith(
            (async () => {
                try { return await fetch(req, { cache: 'no-store', credentials: 'same-origin' }); }
                catch { return (await caches.match('/')) || new Response('Offline', { status:503 }); }
            })()
        );
        return;
    }

    // Auth endpoints: never cache; also clear caches on logout
    if (isAuth(req.url)) {
        event.respondWith(fetch(req, { cache: 'no-store', credentials: 'same-origin' }).then(r => {
            if (new URL(req.url).pathname.toLowerCase().includes('/site/logout')) {
                caches.keys().then(keys => Promise.all(keys.map(k => caches.delete(k))));
            }
            return r;
        }));
        return;
    }

    // Static assets: cache-first
    if (req.destination === 'style' || req.destination === 'script' || req.destination === 'image' || req.url.endsWith('.css') || req.url.endsWith('.js')) {
        event.respondWith(
            caches.match(req).then(cached => cached || fetch(req).then(resp => {
                const clone = resp.clone(); caches.open('runtime-v4').then(c => c.put(req, clone)); return resp;
            }))
        );
        return;
    }

    // Default: network-first with fallback
    event.respondWith(
        fetch(req).then(resp => { const clone = resp.clone(); caches.open('runtime-v4').then(c => c.put(req, clone)); return resp; }).catch(() => caches.match(req))
    );
});
