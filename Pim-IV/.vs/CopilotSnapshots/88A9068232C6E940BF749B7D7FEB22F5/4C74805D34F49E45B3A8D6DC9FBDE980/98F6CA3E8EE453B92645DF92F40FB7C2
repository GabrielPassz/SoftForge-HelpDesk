using Supabase; // Uso do cliente Supabase para integração com banco e realtime
using Microsoft.EntityFrameworkCore; // EF Core para acesso ao banco de dados
using PIM_FINAL.Data; // Contexto de dados da aplicação
using Microsoft.AspNetCore.Authentication.Cookies; // Autenticação via cookies
using Microsoft.AspNetCore.Authorization; // Autorização e políticas
using PIM_FINAL.Services; // Serviços customizados (IA)
using Microsoft.AspNetCore.StaticFiles; // Configuração de arquivos estáticos
using Microsoft.AspNetCore.Mvc.Razor; // Extensões Razor (runtime compilation em debug)
using Microsoft.AspNetCore.Mvc; // MVC base (necessário para extensões)

var builder = WebApplication.CreateBuilder(args); // Criação do builder principal da aplicação ASP.NET Core

// Registro e inicialização do cliente Supabase (usa variáveis de ambiente ou appsettings)
builder.Services.AddSingleton<Supabase.Client>(sp =>
{
    var url = Environment.GetEnvironmentVariable("SUPABASE_URL") ?? builder.Configuration["SUPABASE_URL"]; // Obtém URL do Supabase
    var key = Environment.GetEnvironmentVariable("SUPABASE_KEY") ?? builder.Configuration["SUPABASE_KEY"]; // Obtém chave pública do Supabase
    var options = new Supabase.SupabaseOptions
    {
        AutoConnectRealtime = true // Habilita conexão automática com canal realtime
    };

    var client = new Supabase.Client(url, key, options); // Instancia o cliente
    client.InitializeAsync().GetAwaiter().GetResult(); // Inicialização síncrona para garantir disponibilidade
    return client; // Registra singleton
});

// Configuração do DbContext usando Npgsql (connection string em configuração)
builder.Services.AddDbContext<PIMContext>(options =>
    options.UseNpgsql(builder.Configuration["SUPABASE_DB_CONNECTION"]));

// Configuração de autenticação via Cookie (definindo caminhos de login e access denied)
builder.Services.AddAuthentication(CookieAuthenticationDefaults.AuthenticationScheme)
    .AddCookie(options =>
    {
        options.LoginPath = "/site/Login"; // Caminho de redirecionamento quando não autenticado
        options.AccessDeniedPath = "/site/Login"; // Caminho quando acesso negado
    });

// Política de fallback: exige usuário autenticado por padrão em todas as rotas
builder.Services.AddAuthorization(options =>
{
    options.FallbackPolicy = new AuthorizationPolicyBuilder()
        .RequireAuthenticatedUser() // Exige autenticação
        .Build();
});

// Registro do MVC (Controllers + Views)
var mvcBuilder = builder.Services.AddControllersWithViews();
#if DEBUG
try { mvcBuilder.AddRazorRuntimeCompilation(); } catch { /* Ignora falha se pacote não presente */ }
#endif

// Registro de serviços auxiliares (HttpClient e serviço de IA)
builder.Services.AddHttpClient(); // HttpClient compartilhado
builder.Services.AddSingleton<IAiService, RapidAiService>(); // Serviço de IA customizado

var app = builder.Build(); // Construção do pipeline final

// Configuração de tratamento de erros e segurança em produção
if (!app.Environment.IsDevelopment())
{
    app.UseExceptionHandler("/Home/Error"); // Página de erro padrão
    app.UseHsts(); // HTTP Strict Transport Security
}

app.UseHttpsRedirection(); // Redireciona para HTTPS

// Arquivos estáticos com regras diferenciadas em desenvolvimento (evitar cache)
if (app.Environment.IsDevelopment())
{
    app.UseStaticFiles(new StaticFileOptions
    {
        OnPrepareResponse = ctx =>
        {
            // Força não cache para facilitar desenvolvimento
            ctx.Context.Response.Headers["Cache-Control"] = "no-cache, no-store, must-revalidate";
            ctx.Context.Response.Headers["Pragma"] = "no-cache";
            ctx.Context.Response.Headers["Expires"] = "0";
        }
    });
    // Middleware extra para remover cache também em respostas dinâmicas
    app.Use(async (context, next) =>
    {
        context.Response.Headers["Cache-Control"] = "no-store";
        context.Response.Headers["Pragma"] = "no-cache";
        context.Response.Headers["Expires"] = "0";
        await next();
    });
}
else
{
    app.UseStaticFiles(); // Produção: usa comportamento padrão de arquivos estáticos
}

app.UseRouting(); // Habilita roteamento
app.UseAuthentication(); // Insere middleware de autenticação
app.UseAuthorization(); // Insere middleware de autorização

// Rota padrão: direciona para controlador Site e ação Page carregando Login inicialmente
app.MapControllerRoute(
    name: "default",
    pattern: "{controller=Site}/{action=Page}/{viewName=Login}/{id?}");

app.Run(); // Inicia aplicação (loop principal)